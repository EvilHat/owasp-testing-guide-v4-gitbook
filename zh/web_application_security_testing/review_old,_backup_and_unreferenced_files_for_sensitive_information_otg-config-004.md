# 审查旧文件、备份文件和未引用的文件中的敏感信息 (OTG-CONFIG-004)


### 综述
虽然大多数web服务器的文件被服务器自己处理，但是能找到未引用的或这遗忘的文件，这些文件可能会有助于获得基础设施的重要信息或有效登陆凭证。


大多数场景包括重命名后的就版本修改文件，不同语言文件可以被当作源代码文件下载，或者自动或手动备份压缩文件。备份文件也可能由于文件系统的特性被自动生成，比如“文件快照”。


所有这些文件给予了测试者访问内部网络、后门、管理接口甚至登陆凭证来连接管理接口或数据库服务器。

漏洞的重要来源在于这些文件，他们可能和应用程序本身无关，但是在编辑应用文件过程中产生或临时备份文件中产生，又或是遗留的旧文件或未引用文件。在生产服务器上实施在线修改或其他管理行为可能无意中留下备份的文件拷贝，或是自动被编辑器在编辑的过程产生，或被管理员存放在压缩备份文件中。


这些文件很容易被遗忘，并导致严重的安全威胁。这是由于备份文件的文件扩展名可能区别于原始文件。我们生成了 *.tar，.zip 或.gz* 归档文件（被遗忘），显然是不同的扩展名，编辑器自动备份的也一样（比如emacs生成的临时文件 *file* 命名为 *file~* ）。手动备份也可能有这个问题（考虑复制 *file* 到 *file.old* 的情况）。应用的文件系统也可能在你不知道的时候为你的应用创建不同的时间点的 *快照* ，这些可能也能通过web访问到，对应用程序产生一个类似于备份文件但不同的威胁。


总之，这些行为产生应用程序不需要的文件，可能会被web服务器不同方式处理。例如，如果我们复制 *login.asp* 为 *login.asp.old*，那么我们就允许用户下载 *login.asp* 的源代码。因为 *login.asp.old* 由于他的扩展名可能当作文本文件被处理，而不是被执行。换而言之，访问 *login.asp* 会引起服务器端执行 *login.asp* 的代码，然而访问 *login.asp.old* 导致 *login.asp.old* 的内容（事实上是服务器端代码）被当作文本返回给用户，并在浏览器中显示。这可能是安全风险，因为敏感信息被泄露了。


通常来说暴露服务器端代码是一个坏主意。不仅仅暴露了不必须的业务逻辑，同时也揭露了应用相关的信息（路径名称、数据结构等等），可能会给攻击者提供帮助。更不要说很多脚本直接内嵌明文的用户名和密码（这是一个粗心的非常危险的编码实践）。


其他引起未引用文件的情况取决于设计或这配置选择，当允许不同种类的应用相关文件，如数据文件、配置文件、日志文件存储在web服务器能够访问的文件系统目录时就会发生。正常情况下，这些文件没有放在能通过web访问的文件系统中的理由，因为他们只被应用层访问，只被应用程序本身使用（不是使用浏览器的不同用户）。


#### 威胁

备份文件和未引用文件可能对web应用程序的安全造成多种威胁：

* 未引用的文件可能暴露敏感信息有助于攻击行为；比如引用文件包含数据库凭证信息，配置文件包含其他隐藏的信息，比如绝对路径等等。
* 未引用的页面可能能够包含攻击应用程序的强大功能函数；比如管理页面不应该从公开页面内容中获得，但是能够被已知路径的用户访问。
* 旧文件和备份文件可能包含在近期版本中已经修复的漏洞；比如 *viewdoc.old.jsp* 可能包含目录遍历漏洞，而 *viewdoc.jsp* 中已经修复，但是这个漏洞仍然可能被发现旧版本的恶意人员利用。
* 备份文件可能暴露页面源代码；比如请求 *viewdoc.bak* 可能返回 *viewdoc.jsp* 的源代码，通过评审源代码可能发现那些很难从盲目的请求中发现的漏洞。
* 备份压缩文件可能包含web目录下的所有文件（甚至web根目录之外的文件）。这允许攻击者能快速枚举整个应用，包括未引用的页面、源代码和包含文件等等。例如如果你遗忘了一个名为 *myservlets.jar.old* 的文件，它包含了一个你实现 servlet类的备份，那么许多敏感信息可能被反编译和逆向工程中获得。
* 在一些例子中，复制或编辑文件不修改文件扩展名，但是修改文件名。例如在windows环境下可能发生这个问题，当文件被复制时候，操作系统自动给文件加上本地语言化的“复制”字符。由于文件扩展名没有改变，可执行文件不会被服务器以明文方式返回，所以这种情况下不会暴露源代码。然而，这些文件也可能十分有害，因为他们可能已经被废弃或包含错误的逻辑，当被调用时候，可能引发应用程序错误，这些诊断信息或许能给攻击者带来有用的信息。
* 日志文件可能包含关于用户的敏感信息，例如URL参数中传递敏感数据，会话ID，已访问URL（可能暴露一些未引用内容）等等。其他日志文件（如FTP日志）可能包含系统管理员维护系统情况的敏感信息。
* 文件系统快照也可能包含那些已经修复的存在漏洞的代码拷贝。例如 */.snapshot/monthly.1/view.php* 可能包含已经修复的存在目录遍历楼的的 */view.php* 文件，这个漏洞能被任何能够访问就版本文件的人利用。


### 如何测试
#### 黑盒测试

测试未引用的文件包括自动化和手动技巧，通常需要以下一系列技巧的组合：

##### 从发布的公开内容中推断文件命名模式

枚举所有应用程序页面和功能。这能通过使用浏览器手动完成，或使用应用爬虫工具。许多应用使用可以识别的命名模式，或者使用可识别的词语来组织文件目录和资源。从已经发布的内容的命名模式，很有可能推断出未引用的页面的名称和目录。例如找到一个名字为 *viewuser.asp* ，那么可以试着找找 *edituser.asp*、*adduser.asp*和*deleteuser.asp*。如果找到一个 */app/user* 目录，可以试着找找 */app/admin* 和 */app/manager* 。


##### 已发布的内容中的其他线索

许多web应用会在已发布的内容中留下通往隐藏页面和隐藏功能的线索。这些线索往往能在JavaScript文件和HTML源代码中发现。所有已经发布的内容中的源代码都应该被手动评审来鉴别关于其他页面和功能的线索。例如：

程序员的注释和注释掉的源代码部分可能指向隐藏内容：

```
<!-- <A HREF="uploadfile.jsp">Upload a document to the server</A> -->
<!-- Link removed while bugs in uploadfile.jsp are fixed          -->
```


JavaScript可能包含特定情况下的用户页面链接：

```
var adminUser=false;
:
if (adminUser) menu.add (new menuItem ("Maintain users", "/admin/useradmin.jsp"));
```


HTML页面可能包含禁用SUBMIT元素的隐藏表单：

```
<FORM action="forgotPassword.jsp" method="post">
    <INPUT type="hidden" name="userID" value="123">
    <!-- <INPUT type="submit" value="Forgot Password"> -->
</FORM>
```


另一个包含未引用的目录的线索在*/robots.txt*文件之中，可能提供如下信息：

```
User-agent: *
Disallow: /Admin
Disallow: /uploads
Disallow: /backup
Disallow: /~jbloggs
Disallow: /include
```


##### 盲目猜测

在最简单的一种方式就是通过请求一系列的常用文件名字来尝试猜测服务器上存在的文件和目录。下面包含netcat的包装脚本可以读取一个字典列表，并实施基本的猜测攻击：

```
#!/bin/bash

server=www.targetapp.com
port=80

while read url
do
echo -ne "$url\t"
echo -e "GET /$url HTTP/1.0\nHost: $server\n" | netcat $server $port | head -1
done | tee outputfile

```


视服务器情况而定，GET请求可能用HEAD请求替代来加速攻击。输出文件可以通过grep过滤来获得有趣的响应。200响应码（OK）通常表明一个合法的自由被发现（假设服务器没有提供一个自定义的“未发现”200响应页面）。同时也查找301响应（Moved）、302响应（Found）、401响应（Unauthorized）、403响应（Forrbidden）和500响应（Internal error），这些响应也表明目录或自由值得深入调查。


基本的猜测攻击应该在web根目录中和其他被鉴别出来的（通过其他枚举手段）中运行。更多高级/有效的猜测攻击如下：

* 通过应用程序已知区域来鉴别扩展名（如jsp，aspx，html），使用基本字典加上这些扩展名（或使用更多的扩展名字典，如果条件允许）。
* 对于每一个从其他枚举技巧中发现的文件，创建一个从这些文件衍生出的自定义的字典。使用一系列常见的文件修饰扩展（包括~，bak，txt，src，dev，old，inc，orig，copy，tmp等等），在实际文件名的前面、后面加入这些扩展，或直接替代文件名。


注意：在windows环境下，当文件被复制时候，操作系统自动给文件加上本地语言化的“复制”字符。由于文件扩展名没有改变，这种情况下不会暴露源代码。然而，这些文件可能引发应用程序错误，能给攻击者带来有用的信息。


##### 从服务器漏洞和错误配置中获得的信息

最显而易见在错误配置的服务器中暴露未引用页面的方法是通过目录列举浏览。请求枚举获得的目录来鉴别那些目录提供目录列举功能。

大多在个人web服务器中发现的漏洞能允许攻击者枚举未引用的内容，例如：

* Apache ?M=D 目录列举漏洞
* 不同的IIS脚本源代码暴露漏洞
* IIS WebDAV 目录列举漏洞


##### 利用公开信息

一些面向互联网的应用页面和功能可能不被应用本身链接引用，但是很可能被外部公开主体引用。下面是一些不同引用源：
* 页面可能出现在互联网的搜索引擎归档中。例如 *1998results.asp* 可能已经不再公司的网站上被链接，但是可能还存在于服务器上和搜索引擎数据库中。一些旧脚本可能包含攻破整个站点的漏洞。 *site:* Google搜索操作符可能用于查询相关域名，如 *site:www.example.com*。使用搜索引擎也有一系列的技巧，可以参照 本指南的 *Google Hacking* 部分。使用这些技巧来打磨你的测试技艺。备份文件可能不被任何其他文件引用，因此也可能没有被Google收录，但是如果他们存在于可列举浏览的目录中的话，搜索引擎可能也能收录他们。
* 此外，Google和Yahoo可能缓存他们机器人发现的页面。甚至 *1998results.asp* 已经被目标服务器移除，搜索引擎中也可能存在其中的某个版本的输出内容。被缓存的版本也能包含引用其他隐藏内容的线索。
* 没有被目标应用程序引用的一些内容可能被第三方的站点链接。例如，一个处理在线支付的应用可能包括一系列的定制的功能只能被站点的客户使用。


##### 文件名过滤绕过

因为一些黑名单过滤器是基于正则表达式的，有些可以利用操作系统文件名展开的特性（往往没有被开发者预料到）。测试者可以通过文件名被应用程序、web服务器、操作系统和操作系统文件名转换的不同差异来绕过过滤器。


例子： Windows 8.3 文件名扩展。
```
"c:\program files" 变成了 "C:\PROGRA~1"

规则：
* 移除不兼容字符
* 将空格转换成下划线
* 取文件名前六个字符
* 加入“~<数字>”来区分相同6个初始字符的文件
* 在最初的三个文件名冲突后转换将改变（？）
* 截取文件扩展名前三位
* 将所有字符大写
```


#### 灰盒测试

实施灰盒测试需要检查web目录下被web服务器支持的所有目录文件。理论上，这个检查应该手动完成来确保完备。但是在大多数情况下，复制文件或者备份文件使用类似的命名模式，可以使用脚本来搜寻这些文件。例如，编辑器可能在备份拷贝上加入可识别的扩展或后缀，人们可能会加入“.old”或类似的可预测的扩展名字。一个好的策略是创建一个周期性的计划任务来检查这些文件扩展，并鉴别出是拷贝文件还是备份文件，并同时实施手动检测（更加耗时的）。


### 测试工具

* 漏洞评估工具来发现有通用名字的web目录（如“admin”，“test”，“backup”等等），和一些允许目录浏览的目录。如果你无法获得目录列举，也应该检查可能存在的备份扩展名。考虑Nessus(http://www.nessus.org)， Nikto2(http://www.cirt.net/code/nikto.shtml) ，Wikto (http://www.sensepost.com/research/wikto/)的例子，这些也支持Google Hacking策略。
* Web爬虫工具： wget (http://www.gnu.org/software/wget/,   http://www.interlog.com/~tcharron/wgetwin.html); Sam Spade (http://www.samspade.org); Spike proxy includes a web site crawler function (http://www.immunitysec.com/spikeproxy.html); Xenu (http://home.snafu.de/tilman/xenulink.html); curl (http://curl.haxx.se). 有些工具已经被标准Linux发布版本中集成。
* Web开发工具通常包含识别错误链接和未引用文件的功能。


### 整改措施
为了保证一个有效的保护策略，测试应该被结合安全策略，这些策略应该明显地禁止危险的实践，比如：


* 在web服务器或应用程序的操作系统上原地修改文件。这是一个非常坏的习惯，因为他很有可能不经意产生编辑器的备份文件。令人惊奇的是这往往经常发生，甚至见于一些大组织。如果你确实需要在生产系统上编辑文件，确保你没有遗留下任何没有明显目地的文件，并认清这么做的风险。
* 仔细检查web服务器暴露在外面的那些实施文件系统操作的活动，如管理员活动。例如，如果你偶尔需要给一系列目录做文件快照（当然你不应该在生产系统上这么做），你可能会压缩这些文件。小心不要忘了这些归档文件。
* 合适的配置管理策略应该有助于管理这些遗留的和为引用的文件。
* 应用程序应该被设计为不创建（或依赖于）在web目录树下被web服务器服务的文件。数据文件、日志文件、配置文件等等应该被存储与无法被web服务器访问的目录中，来对抗可能信息泄露情况（不要提供数据修改，如果web目录可写）。
* 在一些文件系统中，如果文件根目录使用了快照技巧，那么文件系统快照不应该被web访问。配置web服务器来拒绝这些目录的访问，例如在apache下，可以如下配置：
```
<Location ~ ".snapshot">
    Order deny,allow
    Deny from all
</Location>
```
